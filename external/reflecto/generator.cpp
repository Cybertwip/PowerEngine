// generator/generator.cpp
#include <iostream>
#include <fstream>
#include <filesystem>
#include <any>
#include "peglib.h"

int main(int argc, char** argv) {
	if (argc != 4) {
		std::cerr << "Usage: generator <input_header_full_path> <output_cpp_full_path> <header_relative_path>\n";
		return 1;
	}
	const char* input_path = argv[1];
	const char* output_path = argv[2];
	const char* relative_header_path = argv[3];
	
	// --- Grammar now uses the 'powergen' namespace for attributes ---
	peg::parser parser(R"(
		File            <- _ Struct* _
		Struct          <- '[[powergen::reflectable]]' _ 'struct' _ Name '{' _ Members '};' _
		Members         <- (Field / Method / Other)*
		Field           <- '[[powergen::field]]' _ Type Name ';' _
		Method          <- '[[powergen::method]]' _ Type Name '(' PList? ')' CQual? '{' Body '}' _
	
		Name            <- < [a-zA-Z_][a-zA-Z0-9_:]* >  # Allow namespaces like std::
		Type            <- Name ('<' Type (',' _ Type)* '>')? ('&' / 'const' / '*')*
		PList           <- Type Name (',' _ PList)?
		CQual           <- 'const'
		Body            <- ( !'}' . )*
	
		# --- REVISED SKIPPING LOGIC ---
		# Other now safely consumes a single character if it's not part of a known rule.
		# This is slow but prevents the parser from getting stuck or overflowing the stack.
		Other           <- !'}' .
	
		# --- IMPROVED WHITESPACE/COMMENT HANDLING ---
		# ~_ now consumes whitespace AND C++ comments
		~_              <- ( [ \t\r\n] / CppComment )*
		CppComment      <- '//' [^\r\n]* / '/*' ( !'*/' . )* '*/'
	)");

	
	std::string struct_name;
	std::vector<std::string> field_names;
	std::vector<std::string> method_names;
	
	// FIX: Use std::any_cast<std::string> to correctly extract the string from the std::any object.
	// This resolves the "No member named 'string' in 'std::any'" error.
	parser["Struct"] = [&](const peg::SemanticValues& sv) { struct_name = std::any_cast<std::string>(sv[0]); };
	parser["Field"]  = [&](const peg::SemanticValues& sv) { field_names.push_back(std::any_cast<std::string>(sv[1])); };
	parser["Method"] = [&](const peg::SemanticValues& sv) { method_names.push_back(std::any_cast<std::string>(sv[1])); };
	
	std::ifstream ifs(input_path);
	if (!ifs) {
		std::cerr << "Error: Could not open input file " << input_path << std::endl;
		return 1;
	}
	
	if (!parser.parse(std::string(std::istreambuf_iterator<char>(ifs), {})) || struct_name.empty()) {
		// This is not an error, it just means the file has no reflectable structs.
		// We create an empty output file to satisfy the build system's dependency tracking.
		std::ofstream ofs(output_path);
		ofs << "// No reflectable structs found in " << relative_header_path << "\n";
		return 0; // Exit successfully
	}
	
	// --- Generate RTTR and Power Reflection Registration Code ---
	// Ensure the output directory exists before writing the file.
	std::filesystem::path out_p(output_path);
	if (out_p.has_parent_path()) {
		std::filesystem::create_directories(out_p.parent_path());
	}
	
	std::ofstream ofs(output_path);
	ofs << "// DO NOT EDIT - Code generated by 'generator' from " << relative_header_path << "\n";
	
	// FIX: Use the relative path passed as an argument for a correct #include directive.
	ofs << "#include \"" << relative_header_path << "\"\n";
	ofs << "#include \"power/reflection.h\"\n"; // Assumes 'src' is an include dir, so 'power/reflection.h' is found.
	ofs << "#include <rttr/registration>\n\n";
	
	// 1. Generate the standard RTTR registration block
	ofs << "RTTR_REGISTRATION {\n";
	ofs << "    rttr::registration::class_<" << struct_name << ">(\"" << struct_name << "\")\n";
	ofs << "        .constructor<>()\n";
	for (const auto& name : field_names) {
		ofs << "        .property(\"" << name << "\", &" << struct_name << "::" << name << ")\n";
	}
	for (const auto& name : method_names) {
		ofs << "        .method(\"" << name << "\", &" << struct_name << "::" << name << ")\n";
	}
	ofs << "    ;\n";
	ofs << "}\n\n";
	
	// 2. Generate the static auto-registration instance for Power Reflection
	ofs << "// Static registration helper for the Power Reflection system\n";
	ofs << "namespace {\n";
	ofs << "    power::reflection::AutoRegistrator<" << struct_name << "> auto_register_" << struct_name << ";\n";
	ofs << "}\n";
	
	std::cout << "Generated Power Reflection code for " << struct_name << std::endl;
	return 0;
}
