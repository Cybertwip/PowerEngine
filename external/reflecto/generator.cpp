// generator/generator.cpp
#include <iostream>
#include <fstream>
#include "peglib.h"

int main(int argc, char** argv) {
    if (argc != 3) {
        std::cerr << "Usage: generator <input_header> <output_header>\n";
        return 1;
    }
    const char* input_path = argv[1];
    const char* output_path = argv[2];

    // --- Grammar now uses the 'powergen' namespace for attributes ---
    peg::parser parser(R"(
        File            <- _ Struct* _
        Struct          <- '[[powergen::reflectable]]' _ 'struct' _ Name '{' _ Members '};' _
        Members         <- (Field | Method | Other)*
        Field           <- '[[powergen::field]]' _ Type Name ';' _
        Method          <- '[[powergen::method]]' _ Type Name '(' PList? ')' CQual? '{' Body '}' _
        
        Name            <- < [a-zA-Z_][a-zA-Z0-9_]* >
        Type            <- Name ('<' Type '>')?
        PList           <- Type Name (',' PList)?
        CQual           <- 'const'
        Body            <- (!'}' .)*
        Other           <- (!'}' .)*
        ~_              <- [ \t\r\n]+
    )");
    
    std::string struct_name;
    std::vector<std::string> field_names;
    std::vector<std::string> method_names;

    parser["Struct"] = [&](const peg::SemanticValues& sv) { struct_name = sv[0]; };
    parser["Field"]  = [&](const peg::SemanticValues& sv) { field_names.push_back(sv[1]); };
    parser["Method"] = [&](const peg::SemanticValues& sv) { method_names.push_back(sv[1]); };

    std::ifstream ifs(input_path);
    if (!parser.parse(std::string(std::istreambuf_iterator<char>(ifs), {}))) {
        std::cerr << "Failed to parse " << input_path << std::endl;
        return 1;
    }

    // --- Generate RTTR and Power Reflection Registration Code ---
    std::ofstream ofs(output_path);
    ofs << "// DO NOT EDIT - Code generated by 'generator'\n";
    ofs << "#include \"src/user_data.h\"\n";
    ofs << "#include \"src/reflection.h\"\n"; // Include the Power Reflection header
    ofs << "#include <rttr/registration>\n\n";

    // 1. Generate the standard RTTR registration block
    ofs << "RTTR_REGISTRATION {\n";
    ofs << "    rttr::registration::class_<" << struct_name << ">(\"" << struct_name << "\")\n";
    ofs << "        .constructor<>()\n";
    for (const auto& name : field_names) {
        ofs << "        .property(\"" << name << "\", &" << struct_name << "::" << name << ")\n";
    }
    for (const auto& name : method_names) {
        ofs << "        .method(\"" << name << "\", &" << struct_name << "::" << name << ")\n";
    }
    ofs << "    ;\n";
    ofs << "}\n\n";

    // 2. Generate the static auto-registration instance for Power Reflection
    ofs << "// Static registration helper for the Power Reflection system\n";
    ofs << "namespace {\n";
    ofs << "    power::reflection::AutoRegistrator<" << struct_name << "> auto_register_" << struct_name << ";\n";
    ofs << "}\n";

    std::cout << "Generated Power Reflection code for " << struct_name << std::endl;
    return 0;
}
