
/*
 * =====================================================================================
 *
 * Filename:  BlueprintSerializer.cpp
 *
 * Description:  Implementation file for the BlueprintSerializer class.
 *
 * =====================================================================================
 */
// #include "BlueprintSerializer.hpp" // This would be included in a real project structure
#include "execution/NodeProcessor.hpp"
#include "execution/BlueprintNode.hpp"
#include "execution/KeyPressNode.hpp"
#include "execution/KeyReleaseNode.hpp"
#include "execution/StringNode.hpp"
#include "execution/PrintNode.hpp"

#include <fstream>
#include <vector>
#include <any>

// Include the header generated by the FlatBuffers compiler
#include "blueprint_generated.h"

namespace {

// Helper function to serialize the data payload from a C++ std::any to a FlatBuffers union.
flatbuffers::Offset<Power::Schema::BlueprintPayload> serialize_payload(
																	   flatbuffers::FlatBufferBuilder& builder,
																	   const std::optional<std::any>& data)
{
	if (!data.has_value()) {
		return 0;
	}
	
	const std::any& value = data.value();
	Power::Schema::BlueprintPayloadData payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_NONE;
	flatbuffers::Offset<void> payload_offset;
	
	if (value.type() == typeid(std::string)) {
		payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_s;
		payload_offset = Power::Schema::CreateStringVal(builder, builder.CreateString(std::any_cast<std::string>(value))).Union();
	} else if (value.type() == typeid(long)) {
		payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_i;
		payload_offset = Power::Schema::CreateLongVal(builder, std::any_cast<long>(value)).Union();
	} else if (value.type() == typeid(int)) { // Also handle int, casting to long for storage
		payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_i;
		payload_offset = Power::Schema::CreateLongVal(builder, static_cast<long>(std::any_cast<int>(value))).Union();
	} else if (value.type() == typeid(float)) {
		payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_f;
		payload_offset = Power::Schema::CreateFloatVal(builder, std::any_cast<float>(value)).Union();
	} else if (value.type() == typeid(bool)) {
		payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_b;
		payload_offset = Power::Schema::CreateBoolVal(builder, std::any_cast<bool>(value)).Union();
	} else if (value.type() == typeid(Entity)) {
		payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_e;
		payload_offset = Power::Schema::CreateBlueprintEntityPayload(builder, std::any_cast<Entity>(value).id).Union();
	}
	
	if (payload_type != Power::Schema::BlueprintPayloadData::BlueprintPayloadData_NONE) {
		return Power::Schema::CreateBlueprintPayload(builder, payload_type, payload_offset);
	}
	
	return 0;
}

// Helper function to deserialize a FlatBuffers payload union back into a C++ std::any.
std::optional<std::any> deserialize_payload(
											const Power::Schema::BlueprintPayload* payload)
{
	if (!payload || payload->data_type() == Power::Schema::BlueprintPayloadData::BlueprintPayloadData_NONE) {
		return std::nullopt;
	}
	
	switch (payload->data_type()) {
		case Power::Schema::BlueprintPayloadData::BlueprintPayloadData_s:
			return std::string(payload->data_as_s()->str()->c_str());
		case Power::Schema::BlueprintPayloadData::BlueprintPayloadData_i:
			return payload->data_as_i()->val();
		case Power::Schema::BlueprintPayloadData::BlueprintPayloadData_f:
			return payload->data_as_f()->val();
		case Power::Schema::BlueprintPayloadData::BlueprintPayloadData_b:
			return payload->data_as_b()->val();
		case Power::Schema::BlueprintPayloadData::BlueprintPayloadData_e:
			return Entity{payload->data_as_e()->id(), std::nullopt};
		default:
			return std::nullopt;
	}
}

} // namespace


void BlueprintSerializer::serialize(const NodeProcessor& node_processor, const std::string& filepath) {
	flatbuffers::FlatBufferBuilder builder(1024);
	
	std::vector<flatbuffers::Offset<Power::Schema::BlueprintNode>> node_offsets;
	for (const auto& node : node_processor.get_nodes()) {
		std::vector<flatbuffers::Offset<Power::Schema::BlueprintPin>> input_pin_offsets;
		for (const auto& pin : node->get_inputs()) {
			auto pin_payload_offset = serialize_payload(builder, pin->get_data());
			// PinSubType is removed from the CreateBlueprintPin call as it's no longer needed.
			input_pin_offsets.push_back(Power::Schema::CreateBlueprintPin(
																		  builder,
																		  pin->id,
																		  static_cast<Power::Schema::PinType>(pin->type),
																		  static_cast<Power::Schema::PinKind>(pin->kind),
																		  pin_payload_offset));
		}
		
		std::vector<flatbuffers::Offset<Power::Schema::BlueprintPin>> output_pin_offsets;
		for (const auto& pin : node->get_outputs()) {
			auto pin_payload_offset = serialize_payload(builder, pin->get_data());
			output_pin_offsets.push_back(Power::Schema::CreateBlueprintPin(
																		   builder,
																		   pin->id,
																		   static_cast<Power::Schema::PinType>(pin->type),
																		   static_cast<Power::Schema::PinKind>(pin->kind),
																		   pin_payload_offset));
		}
		
		flatbuffers::Offset<Power::Schema::BlueprintPayload> node_payload_offset = 0;
		if (auto* data_node = dynamic_cast<const DataCoreNode*>(node.get())) {
			node_payload_offset = serialize_payload(builder, data_node->get_data());
		}
		
		auto position = Power::Schema::Vec2i(node->position.x(), node->position.y());
		node_offsets.push_back(Power::Schema::CreateBlueprintNode(
																  builder,
																  node->id,
																  static_cast<Power::Schema::NodeType>(node->type),
																  &position,
																  builder.CreateVector(input_pin_offsets),
																  builder.CreateVector(output_pin_offsets),
																  node_payload_offset));
	}
	
	std::vector<flatbuffers::Offset<Power::Schema::BlueprintLink>> link_offsets;
	for (const auto& link : node_processor.get_links()) {
		link_offsets.push_back(Power::Schema::CreateBlueprintLink(
																  builder,
																  link->get_id(),
																  link->get_start().node.id,
																  link->get_start().id,
																  link->get_end().node.id,
																  link->get_end().id));
	}
	
	auto blueprint_offset = Power::Schema::CreateBlueprint(
														   builder,
														   builder.CreateVector(node_offsets),
														   builder.CreateVector(link_offsets));
	builder.Finish(blueprint_offset);
	
	std::ofstream ofs(filepath, std::ios::binary);
	ofs.write(reinterpret_cast<const char*>(builder.GetBufferPointer()), builder.GetSize());
}


void BlueprintSerializer::deserialize(NodeProcessor& node_processor, const std::string& filepath) {
	std::ifstream ifs(filepath, std::ios::binary | std::ios::ate);
	if (!ifs.is_open()) return;
	
	auto size = ifs.tellg();
	if (size <= 0) return;
	ifs.seekg(0, std::ios::beg);
	
	std::vector<char> buffer(size);
	ifs.read(buffer.data(), size);
	ifs.close();
	
	auto blueprint = Power::Schema::GetBlueprint(buffer.data());
	auto verifier = flatbuffers::Verifier(reinterpret_cast<const uint8_t*>(buffer.data()), buffer.size());
	if (!blueprint->Verify(verifier)) {
		return;
	}
	
	node_processor.clear();
	
	if (blueprint->nodes()) {
		for (const auto* fb_node : *blueprint->nodes()) {
			if (!fb_node) continue;
			
			CoreNode* core_node_ptr = nullptr;
			switch (fb_node->type()) {
				case Power::Schema::NodeType::NodeType_KeyPress:
					core_node_ptr = &node_processor.spawn_node<KeyPressCoreNode>(fb_node->id());
					break;
				case Power::Schema::NodeType::NodeType_KeyRelease:
					core_node_ptr = &node_processor.spawn_node<KeyReleaseCoreNode>(fb_node->id());
					break;
				case Power::Schema::NodeType::NodeType_String:
					core_node_ptr = &node_processor.spawn_node<StringCoreNode>(fb_node->id());
					break;
				case Power::Schema::NodeType::NodeType_Print:
					core_node_ptr = &node_processor.spawn_node<PrintCoreNode>(fb_node->id());
					break;
			}
			if (!core_node_ptr) continue;
			
			core_node_ptr->set_position({fb_node->position()->x(), fb_node->position()->y()});
			
			if (auto* data_node = dynamic_cast<DataCoreNode*>(core_node_ptr)) {
				if (fb_node->data()) {
					data_node->set_data(deserialize_payload(fb_node->data()));
				}
			}
			
			// Get non-const access to the pins that were just randomly generated by the node constructor.
			auto& core_inputs = const_cast<std::vector<std::unique_ptr<CorePin>>&>(core_node_ptr->get_inputs());
			auto& core_outputs = const_cast<std::vector<std::unique_ptr<CorePin>>&>(core_node_ptr->get_outputs());
			
			// Overwrite the new pins' IDs and data with the saved data.
			if (fb_node->inputs() && core_inputs.size() == fb_node->inputs()->size()) {
				for (flatbuffers::uoffset_t i = 0; i < core_inputs.size(); ++i) {
					const auto* fb_pin = fb_node->inputs()->Get(i);
					if (!fb_pin) continue;
					core_inputs[i]->id = fb_pin->id(); // CRITICAL: Assign the saved ID
					core_inputs[i]->set_data(deserialize_payload(fb_pin->data()));
				}
			}
			if (fb_node->outputs() && core_outputs.size() == fb_node->outputs()->size()) {
				for (flatbuffers::uoffset_t i = 0; i < core_outputs.size(); ++i) {
					const auto* fb_pin = fb_node->outputs()->Get(i);
					if (!fb_pin) continue;
					core_outputs[i]->id = fb_pin->id(); // CRITICAL: Assign the saved ID
					core_outputs[i]->set_data(deserialize_payload(fb_pin->data()));
				}
			}
		}
	}
	
	if (blueprint->links()) {
		for (const auto* fb_link : *blueprint->links()) {
			if (!fb_link) continue;
			// This now works because the pins have the correct, deserialized IDs.
			auto* start_node = node_processor.find_node(fb_link->start_node_id());
			auto* end_node = node_processor.find_node(fb_link->end_node_id());
			
			if(start_node && end_node) {
				auto& start_pin = start_node->get_pin(fb_link->start_pin_id());
				auto& end_pin = end_node->get_pin(fb_link->end_pin_id());
				node_processor.create_link(fb_link->id(), start_pin, end_pin);
			}
		}
	}
}
