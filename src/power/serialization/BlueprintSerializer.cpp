#include "BlueprintSerializer.hpp"
#include "execution/NodeProcessor.hpp"
#include "execution/BlueprintNode.hpp"
#include "execution/KeyPressNode.hpp"
#include "execution/KeyReleaseNode.hpp"
#include "execution/StringNode.hpp"
#include "execution/PrintNode.hpp"

#include <fstream>
#include <vector>
#include <variant>

// Include the header generated by the FlatBuffers compiler
#include "blueprint_generated.h"

namespace {

// Helper function to serialize the data payload from a C++ variant to a FlatBuffers union.
flatbuffers::Offset<Power::Schema::BlueprintPayload> serialize_payload(
																	   flatbuffers::FlatBufferBuilder& builder,
																	   const std::optional<std::variant<Entity, std::string, long, float, bool>>& data)
{
	if (!data.has_value()) {
		return 0;
	}
	
	Power::Schema::BlueprintPayloadData payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_NONE;
	flatbuffers::Offset<void> payload_offset;
	
	std::visit([&](auto&& arg) {
		using T = std::decay_t<decltype(arg)>;
		if constexpr (std::is_same_v<T, std::string>) {
			payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_s;
			payload_offset = Power::Schema::CreateStringVal(builder, builder.CreateString(arg)).Union();
		} else if constexpr (std::is_same_v<T, int>) {
			payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_i;
			payload_offset = Power::Schema::CreateIntVal(builder, arg).Union();
		} else if constexpr (std::is_same_v<T, float>) {
			payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_f;
			payload_offset = Power::Schema::CreateFloatVal(builder, arg).Union();
		} else if constexpr (std::is_same_v<T, bool>) {
			payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_b;
			payload_offset = Power::Schema::CreateBoolVal(builder, arg).Union();
		} else if constexpr (std::is_same_v<T, Entity>) {
			payload_type = Power::Schema::BlueprintPayloadData::BlueprintPayloadData_e;
			payload_offset = Power::Schema::CreateBlueprintEntityPayload(builder, arg.id).Union();
		}
	}, data.value());
	
	// FIXED: Condition was incorrect, preventing strings from being saved.
	// If a payload was created (i.e., its type is not NONE), wrap it in a BlueprintPayload object.
	if (payload_type != Power::Schema::BlueprintPayloadData::BlueprintPayloadData_NONE) {
		return Power::Schema::CreateBlueprintPayload(builder, payload_type, payload_offset);
	}
	
	return 0;
}

// Helper function to deserialize a FlatBuffers payload union back into a C++ variant.
std::optional<std::variant<Entity, std::string, long, float, bool>> deserialize_payload(
																					   const Power::Schema::BlueprintPayload* payload)
{
	// FIXED: Condition was incorrect, preventing strings from being loaded.
	if (!payload || payload->data_type() == Power::Schema::BlueprintPayloadData::BlueprintPayloadData_NONE) {
		return std::nullopt;
	}
	
	switch (payload->data_type()) {
		case Power::Schema::BlueprintPayloadData::BlueprintPayloadData_s:
			// FIXED: Correctly access the string value.
			return payload->data_as_s()->str()->str();
		case Power::Schema::BlueprintPayloadData::BlueprintPayloadData_i:
			return payload->data_as_i()->val();
		case Power::Schema::BlueprintPayloadData::BlueprintPayloadData_f:
			return payload->data_as_f()->val();
		case Power::Schema::BlueprintPayloadData::BlueprintPayloadData_b:
			return payload->data_as_b()->val();
		case Power::Schema::BlueprintPayloadData::BlueprintPayloadData_e:
			return Entity{payload->data_as_e()->id(), std::nullopt};
		default:
			return std::nullopt;
	}
}

} // namespace


void BlueprintSerializer::serialize(const NodeProcessor& node_processor, const std::string& filepath) {
	flatbuffers::FlatBufferBuilder builder(1024);
	
	std::vector<flatbuffers::Offset<Power::Schema::BlueprintNode>> node_offsets;
	for (const auto& node : node_processor.get_nodes()) {
		std::vector<flatbuffers::Offset<Power::Schema::BlueprintPin>> input_pin_offsets;
		for (const auto& pin : node->get_inputs()) {
			auto pin_payload_offset = serialize_payload(builder, pin->get_data());
			input_pin_offsets.push_back(Power::Schema::CreateBlueprintPin(
																		  builder,
																		  pin->id,
																		  static_cast<Power::Schema::PinType>(pin->type),
																		  static_cast<Power::Schema::PinSubType>(pin->subtype),
																		  static_cast<Power::Schema::PinKind>(pin->kind),
																		  pin_payload_offset));
		}
		
		std::vector<flatbuffers::Offset<Power::Schema::BlueprintPin>> output_pin_offsets;
		for (const auto& pin : node->get_outputs()) {
			auto pin_payload_offset = serialize_payload(builder, pin->get_data());
			output_pin_offsets.push_back(Power::Schema::CreateBlueprintPin(
																		   builder,
																		   pin->id,
																		   static_cast<Power::Schema::PinType>(pin->type),
																		   static_cast<Power::Schema::PinSubType>(pin->subtype),
																		   static_cast<Power::Schema::PinKind>(pin->kind),
																		   pin_payload_offset));
		}
		
		flatbuffers::Offset<Power::Schema::BlueprintPayload> node_payload_offset = 0;
		if (auto* data_node = dynamic_cast<const DataCoreNode*>(node.get())) {
			node_payload_offset = serialize_payload(builder, data_node->get_data());
		}
		
		auto position = Power::Schema::Vec2i(node->position.x(), node->position.y());
		node_offsets.push_back(Power::Schema::CreateBlueprintNode(
																  builder,
																  node->id,
																  static_cast<Power::Schema::NodeType>(node->type),
																  &position,
																  builder.CreateVector(input_pin_offsets),
																  builder.CreateVector(output_pin_offsets),
																  node_payload_offset));
	}
	
	std::vector<flatbuffers::Offset<Power::Schema::BlueprintLink>> link_offsets;
	for (const auto& link : node_processor.get_links()) {
		link_offsets.push_back(Power::Schema::CreateBlueprintLink(
																  builder,
																  link->get_id(),
																  link->get_start().node.id,
																  link->get_start().id,
																  link->get_end().node.id,
																  link->get_end().id));
	}
	
	auto blueprint_offset = Power::Schema::CreateBlueprint(
														   builder,
														   builder.CreateVector(node_offsets),
														   builder.CreateVector(link_offsets));
	builder.Finish(blueprint_offset);
	
	std::ofstream ofs(filepath, std::ios::binary);
	ofs.write(reinterpret_cast<const char*>(builder.GetBufferPointer()), builder.GetSize());
}


void BlueprintSerializer::deserialize(NodeProcessor& node_processor, const std::string& filepath) {
	std::ifstream ifs(filepath, std::ios::binary | std::ios::ate);
	if (!ifs.is_open()) return;
	
	auto size = ifs.tellg();
	if (size <= 0) return;
	ifs.seekg(0, std::ios::beg);
	
	std::vector<char> buffer(size);
	ifs.read(buffer.data(), size);
	ifs.close();
	
	auto blueprint = Power::Schema::GetBlueprint(buffer.data());
	auto verifier = flatbuffers::Verifier(reinterpret_cast<const uint8_t*>(buffer.data()), buffer.size());
	if (!blueprint->Verify(verifier)) {
		return;
	}
	
	node_processor.clear();
	
	if (blueprint->nodes()) {
		for (const auto* fb_node : *blueprint->nodes()) {
			if (!fb_node) continue;
			
			CoreNode* core_node_ptr = nullptr;
			switch (fb_node->type()) {
				case Power::Schema::NodeType::NodeType_KeyPress:
					core_node_ptr = &node_processor.spawn_node<KeyPressCoreNode>(fb_node->id());
					break;
				case Power::Schema::NodeType::NodeType_KeyRelease:
					core_node_ptr = &node_processor.spawn_node<KeyReleaseCoreNode>(fb_node->id());
					break;
				case Power::Schema::NodeType::NodeType_String:
					core_node_ptr = &node_processor.spawn_node<StringCoreNode>(fb_node->id());
					break;
				case Power::Schema::NodeType::NodeType_Print:
					core_node_ptr = &node_processor.spawn_node<PrintCoreNode>(fb_node->id());
					break;
			}
			if (!core_node_ptr) continue;
			
			core_node_ptr->set_position({fb_node->position()->x(), fb_node->position()->y()});
			
			if (auto* data_node = dynamic_cast<DataCoreNode*>(core_node_ptr)) {
				if (fb_node->data()) {
					data_node->set_data(deserialize_payload(fb_node->data()));
				}
			}
			
			// --- FIXED PIN DESERIALIZATION LOGIC ---
			// Get non-const access to the pins that were just randomly generated.
			auto& core_inputs = const_cast<std::vector<std::unique_ptr<CorePin>>&>(core_node_ptr->get_inputs());
			auto& core_outputs = const_cast<std::vector<std::unique_ptr<CorePin>>&>(core_node_ptr->get_outputs());
			
			// Overwrite the new pins' IDs and data with the saved data.
			if (fb_node->inputs() && core_inputs.size() == fb_node->inputs()->size()) {
				for (flatbuffers::uoffset_t i = 0; i < core_inputs.size(); ++i) {
					const auto* fb_pin = fb_node->inputs()->Get(i);
					if (!fb_pin) continue;
					core_inputs[i]->id = fb_pin->id(); // CRITICAL: Assign the saved ID
					core_inputs[i]->set_data(deserialize_payload(fb_pin->data()));
				}
			}
			if (fb_node->outputs() && core_outputs.size() == fb_node->outputs()->size()) {
				for (flatbuffers::uoffset_t i = 0; i < core_outputs.size(); ++i) {
					const auto* fb_pin = fb_node->outputs()->Get(i);
					if (!fb_pin) continue;
					core_outputs[i]->id = fb_pin->id(); // CRITICAL: Assign the saved ID
					core_outputs[i]->set_data(deserialize_payload(fb_pin->data()));
				}
			}
		}
	}
	
	if (blueprint->links()) {
		for (const auto* fb_link : *blueprint->links()) {
			if (!fb_link) continue;
			// This now works because the pins have the correct, deserialized IDs.
			auto* start_node = node_processor.find_node(fb_link->start_node_id());
			auto* end_node = node_processor.find_node(fb_link->end_node_id());
			
			if(start_node && end_node) {
				auto& start_pin = start_node->get_pin(fb_link->start_pin_id());
				auto& end_pin = end_node->get_pin(fb_link->end_pin_id());
				node_processor.create_link(fb_link->id(), start_pin, end_pin);
			}
		}
	}
}
